#+STARTTIP: overview
* interface tweaks
#+BEGIN_SRC emacs-lisp
  ;;; package --- summary
  ;;; Commentary:
  ;;; Code:

  ;;disable start screen
  (setq inhibit-startup-screen t)
  (tool-bar-mode -1)

  ;;yes or no prompts to y or n
  (fset 'yes-or-no-p 'y-or-n-p)

  (global-set-key (kbd "<f5>") 'revert-buffer)

  ;;reduce clutter in init file
  (setq custom-file "~/.emacs.d/custom.el")
  (load custom-file)
  ;;(package-initialize)

  ;; Delete my files by moving them to the trash. I'm human and
  ;; occasionally delete things that I actually want later:
  (setq delete-by-moving-to-trash t)

#+END_SRC

#+RESULTS:
: t

* scrolling
#+BEGIN_SRC emacs-lisp
  ;; Emacs has some awful scrolling by default. This gets rid of that.
  (setq scroll-step 1) ; keyboard scroll one line at a time
  (setq scroll-preserve-screen-position 'always)
  (setq scroll-conservatively 101)
  (setq next-screen-context-lines 5)

  ;;mouse scrolling

  ;; scroll one line at a time (less "jumpy" than defaults)
  (setq mouse-wheel-scroll-amount '(3 ((shift) . 1))) ;; one line at a time
  (setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
  (setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
  (setq ring-bell-function 'ignore)

#+END_SRC

* message
#+BEGIN_SRC emacs-lisp
(message "hello from init.el")
(message "hello from ubuntu")
#+END_SRC

* modes
#+BEGIN_SRC emacs-lisp
  (global-visual-line-mode t)
  (diminish 'visual-line-mode)
  (diminish 'eldoc-mode)
  (global-hl-line-mode t)
  (electric-pair-mode 1)
  (show-paren-mode 1) 
  (set-face-attribute 'default nil :height 110)
  (scroll-bar-mode 0)

  ;;linum-mode hooks
  (add-hook 'emacs-lisp-mode-hook 'linum-mode)
  (add-hook 'sh-mode-hook 'linum-mode)
#+END_SRC

#+RESULTS:
| linum-mode |

  
* themes
#+BEGIN_SRC emacs-lisp
  (use-package color-theme-sanityinc-tomorrow
    :ensure t)

  
  #+END_SRC

#+RESULTS:

* don't know if this is required
#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (add-to-list 'load-path "~/.emacs.d/elpa/use-package" user-emacs-directory)
    (require 'use-package))
  (use-package diminish
    :ensure t)
  (use-package bind-key
    :ensure t)
#+END_SRC

* ace-window
#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :ensure t
    :init
    (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
    (setq aw-background nil)
    (progn
      (global-set-key [remap other-window] 'ace-window)
      (custom-set-faces
       '(aw-leading-char-face
	 ((t (:inherit ace-jump-face-foreground :height 3.0)))))
      ))

#+END_SRC

#+RESULTS:

* aggressive-indent
#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
    ;; Keep code indented automatically
    :ensure t
    :defer 10
    :config
    (global-aggressive-indent-mode)
	:diminish)
#+END_SRC

#+RESULTS:
: t

* auctex
#+BEGIN_SRC emacs-lisp :results output silent 
  (use-package tex-site
	;; AuCTeX is better than the built in tex mode; let's use it.  This
	;; demand adds almost nothing and ensures that auctex gets to set itself
	;; up properly. That's necessary because of how weirdly it gets loaded.
	:ensure auctex
	:demand t
	:custom
	(TeX-auto-save t)
	;;(TeX-electric-escape t)
	(TeX-electric-math '("\\(" . "\\)") "Smart $ behavior")
	(TeX-electric-sub-and-superscript t)
	(TeX-parse-self t)
	(reftex-plug-into-AUCTeX t)
	;;(setq font-latex-fontify-script nil) ;; stop changing position of stuff on lines
	(TeX-source-correlate-method 'synctex)
	(TeX-source-correlate-mode t)
	(TeX-clean-confirm nil)
	;; TeX-command-list by default contains a bunch of stuff I'll never
	;; use. I use latexmk, xelatexmk, and View.  That's pretty much it.
	;; Maybe one day I'll add "clean" back to the list.
	;; (TeX-command-list
	;;  '(("latexmk" "latexmk -synctex=1 -quiet -pdf %s"
	;;     TeX-run-compile nil t :help "Process file with latexmk")
	;;    ("View" "%V" TeX-run-discard-or-function nil t :help "Run Viewer")
	;;    ("xelatexmk" "latexmk -synctex=1 -quiet -xelatex %s"
	;;     TeX-run-compile nil t :help "Process file with xelatexmk")))
	:hook
	(LaTeX-mode . LaTeX-math-mode)
	(LaTeX-mode . reftex-mode)
	(LaTeX-mode . TeX-PDF-mode)
	(LaTeX-mode . (lambda ()
					(push
					 '("Make" "latexmk -outdir=/tmp %t" TeX-run-TeX nil t
					   :help "Make pdf output using latexmk.")
					 TeX-command-list)))
	:config
	(setq-default TeX-command-default "latexmk")
	;; revert pdf from file after compilation finishes
	(use-package tex-buf
	  :config
	  (add-hook 'TeX-after-compilation-finished-functions #'TeX-revert-document-buffer))
	(use-package latex
	  :bind
	  (:map LaTeX-mode-map
			("M-p" . outline-previous-visible-heading)
			("M-n" . outline-next-visible-heading)
			("<backtab>" . org-cycle))
	  :config
	  (push "\\.fdb_latexmk" LaTeX-clean-intermediate-suffixes)
	  (push "\\.fls" LaTeX-clean-intermediate-suffixes)
	  (push "\\.synctex.gz" LaTeX-clean-intermediate-suffixes)))
#+END_SRC

#+RESULTS:
| japanese-latex-mode-initialization | er/add-latex-mode-expansions | (lambda nil (push '(Make latexmk -outdir=/tmp %t TeX-run-TeX nil t :help Make pdf output using latexmk.) TeX-command-list)) | preview-mode-setup | (lambda nil (setq TeX-command-list (cons '(Make latexmk -outdir=/tmp %t TeX-run-TeX nil t :help Make pdf output using latexmk.) TeX-command-list))) | TeX-PDF-mode | reftex-mode | LaTeX-math-mode | turn-on-cdlatex |

* Beacon mode
#+BEGIN_SRC emacs-lisp
  ;;   ;; flashes the cursor's line when you scroll
  ;;   (use-package beacon
  ;; 	:ensure t
  ;; 	:config (beacon-mode 1)
  ;; )
#+END_SRC

#+RESULTS:
: t

* cdlatex
#+BEGIN_SRC emacs-lisp
  (use-package cdlatex
	:ensure t
	:hook ((LaTeX-mode . turn-on-cdlatex)
		   ;;(org-mode . turn-on-cdlatex)
)
	)
#+END_SRC

#+RESULTS:
| preview-mode-setup | er/add-latex-mode-expansions | turn-on-cdlatex | (lambda nil (setq TeX-command-list (cons '(Make latexmk -outdir=/tmp %t TeX-run-TeX nil t :help Make pdf output using latexmk.) TeX-command-list))) | TeX-PDF-mode | reftex-mode | LaTeX-math-mode |

* company
#+BEGIN_SRC emacs-lisp
  (use-package company
	;; Company mode provides autocompletion of text and code.
	:ensure t  
	:bind
	(:map company-active-map
		  ("C-s" . company-search-candidates)
		  ("<tab>" . company-complete-common-or-cycle)
		  ("RET" . company-complete-selection)
		  ("C-n" . company-select-next)
		  ("C-p" . company-select-previous))
	:hook
	((prog-mode ess-mode) . company-mode)
	:config
	(defun my/python-mode-hook ()
	  (add-to-list 'company-backends 'company-jedi))
	(add-hook 'python-mode-hook 'my/python-mode-hook)
	:custom
	(company-idle-delay 0.25)
	(company-require-match nil)
	(company-minimum-prefix-length 2)
	:diminish "Company"
	)
#+END_SRC

#+RESULTS:
: company-select-previous

* eclim 
#+BEGIN_SRC emacs-lisp
  ;; (use-package eclim
  ;;   :ensure t
  ;;   :load-path ("~/.emacs.d/elpa/eclim-20171113.1754/")
  ;;   :init
  ;;   (progn
  ;;     (setq eclimd-autostart t
  ;;           eclim-executable "/opt/eclipse/plugins/org.eclim_2.7.2/bin/eclim"
  ;;           eclimd-executable "/opt/eclipse/plugins/org.eclim_2.7.2/bin/eclimd"
  ;;           ;;eclimd-wait-for-process t
  ;;           eclimd-default-workspace "~/my-workspace"
  ;;           eclim-eclipse-dirs "/opt/eclipse"
  ;;           help-at-pt-display-when-idle t
  ;;           help-at-pt-timer-delay 1.0
  ;;           eclim-auto-save nil
  ;;           )
  ;;     (help-at-pt-set-timer)
  ;;     )
  ;;   :hook (java-mode . eclim-mode)
  ;;   )

  ;;   (use-package company-emacs-eclim
  ;;     :ensure t
  ;;     :config (company-emacs-eclim-setup))
#+END_SRC

#+RESULTS:
: t

* exec-path-from-shell
#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :init
    (when (memq window-system '(mac ns x))
      (exec-path-from-shell-initialize)))
#+END_SRC

#+RESULTS:
* Expand region
#+BEGIN_SRC emacs-lisp
  ;; expand the marked region in semantic increments (negative prefix to reduce region)
  (use-package expand-region
	:ensure t
	:config 
	(global-set-key (kbd "C-=") 'er/expand-region))
#+END_SRC

#+RESULTS:
: t

* flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :init (global-flycheck-mode)
    :config 
	:diminish "FlyC"
    ;;(setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))
	;;:diminish
    )
#+END_SRC

#+RESULTS:
| FlyC |
|      |
* flyspell
#+BEGIN_SRC emacs-lisp
  (use-package flyspell
  :ensure t
  :diminish "FlyS")
#+END_SRC

#+RESULTS:
| FlyS |

* gradle
#+BEGIN_SRC emacs-lisp
  (use-package gradle-mode
	:ensure t
	:hook (java-mode . (lambda() (gradle-mode 1))))

  ;; (defun build-and-run (&optional CLASS-NAME)
  ;;   "Get class name from buffer."
  ;;   (interactive "sClass to run (default current buffer): ")
  ;;   (gradle-run (concat "build run -Pmain=" (or CLASS-NAME (file-name-base (buffer-file-name (window-buffer (minibuffer-selected-window))))))))

  (cl-defun build-and-run (&optional CLASS-NAME &key (CLASS-NAME (file-name-base (buffer-file-name (window-buffer (minibuffer-selected-window))))))
	(interactive "sClass to run (default current buffer): ")
	(save-buffer)
	(gradle-run (concat "build run -q -Pmain=" CLASS-NAME)))

  (define-key gradle-mode-map (kbd "C-c C-r") 'build-and-run)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp
  (use-package groovy-mode
    :ensure t
    :hook (//.gradle// . groovy-mode))
#+END_SRC

#+RESULTS:
| groovy-mode |

* Helm
#+BEGIN_SRC emacs-lisp
  ;;; Helm
  (use-package helm
    ;; A package in a league of its own: https://tuhdo.github.io/helm-intro.html
    ;; load it soon after starting Emacs:
    :ensure t
    :defer 1
    :bind
    (("M-x" . helm-M-x)
     ("C-x C-f" . helm-find-files)
     ("M-y" . helm-show-kill-ring)
     ("C-M-z" . helm-resume)
     ([remap occur] . helm-occur)
     ([remap bookmark-jump] . helm-bookmarks)
     ("C-x b" . helm-buffers-list)
     ("C-x C-b" . helm-buffers-list)
     ("M-s M-g" . helm-google-suggest)
     ("M-o" . helm-semantic-or-imenu)
     ("C-h SPC" . helm-all-mark-rings)
     ("M-s g" . helm-grep-do-git-grep)
     :map helm-map
     ("<tab>" . helm-execute-persistent-action)
     ("C-i" . helm-execute-persistent-action)
     ("C-z" . helm-select-action))
    :custom
    (helm-display-header-line nil)
    (helm-echo-input-in-header-line t)
    (helm-net-prefer-curl t)
    (helm-split-window-default-side 'below)
    (helm-split-window-inside-p t)
    (helm-command-prefix-key "M-,")
    :init
    (require 'helm-config)
    :config
    (use-package helm-files
      :config
      (push ".git$" helm-boring-file-regexp-list))
    (use-package helm-org
      :bind
      (:map my/map
            ("t" . helm-org-agenda-files-headings)))
    (helm-mode)
    (use-package helm-swoop
      :ensure t
      :config
      (progn
        (global-set-key (kbd "C-s") 'helm-swoop-without-pre-input)
        ;;(setq helm-swoop-pre-input-function  (lambda () ""))
        (setq helm-swoop-use-fuzzy-match t)
        )
      )
	  :diminish)
#+END_SRC

#+RESULTS:
: helm-select-action

* Hungry Delete
#+BEGIN_SRC emacs-lisp
  ;; deletes all the whitespace when you hit backspace or delete
  (use-package hungry-delete
	:ensure t
	:config
	(global-hungry-delete-mode)
	:diminish)
#+END_SRC

#+RESULTS:
: t

* icons and fonts
#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons
    :ensure t)
#+END_SRC

* jdee
#+BEGIN_SRC emacs-lisp
;;  (use-package jdee
  ;;  :ensure t)
#+END_SRC

#+RESULTS:

* js2
#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :ensure t
    :hook ((//.js// . js2-mode)
           (js2-mode . js2-imenu-extras-mode))
    )

  (use-package js2-refactor
    :ensure t)
#+END_SRC

#+RESULTS:

* latex
#+BEGIN_SRC emacs-lisp :results output silent
  ;; My custom LaTeX class for Org-mode export. require is needed for it to work.
  ;;(setf org-highlight-latex-and-related '(latex))
  (setq org-src-fontify-natively t)
  (setq org-latex-with-hyperref nil)
  (setq org-latex-title-command "\\maketitle")
  (setq org-latex-toc-command "")
  (setq org-export-with-section-numbers nil)
  (setq user-full-name "Nicholas Hanoian")
  (setq org-latex-create-formula-image-program 'imagemagick)
  (setq org-format-latex-options (plist-put org-format-latex-options :scale 2.0))
  (setq org-latex-default-class "homework")
  (setq preview-button-1 '[mouse-1])

  (setq font-latex-fontify-script nil)
  (setq font-latex-fontify-sectioning 'color)



  ;; (defvar texfrag-submap
  ;;  '(let ((map (make-sparse-keymap)))
  ;;   (define-key map "\C-p" #'preview-at-point)
  ;;   (define-key map "\C-r" #'preview-region)
  ;;   (define-key map "\C-b" #'preview-buffer)
  ;;   (define-key map "\C-d" #'preview-document)
  ;;   (define-key map "\C-f" #'preview-cache-preamble)
  ;;   (define-key map "\C-c\C-f" #'preview-cache-preamble-off)
  ;;   (define-key map "\C-i" #'preview-goto-info-page)
  ;;   ;;  (define-key map "\C-q" #'preview-paragraph)
  ;;   (define-key map "\C-e" #'preview-environment)
  ;;   (define-key map "\C-s" #'preview-section)
  ;;   (define-key map "\C-w" #'preview-copy-region-as-mml)
  ;;   (define-key map "\C-c\C-p" #'preview-clearout-at-point)
  ;;   (define-key map "\C-c\C-r" #'preview-clearout)
  ;;   (define-key map "\C-c\C-s" #'preview-clearout-section)
  ;;   (define-key map "\C-c\C-b" #'preview-clearout-buffer)
  ;;   (define-key map "\C-c\C-d" #'preview-clearout-document)
  ;;   map))

  ;;   (texfrag-set-prefix "\C-c\C-p")

  (use-package ov
	:ensure t)

  (unless (boundp 'org-latex-classes)
	(setq org-latex-classes nil))

  (add-to-list 'org-latex-classes
			   '("homework"
				 "\\ProvidesPackage{/home/nick/Dropbox/config/homework}
\\documentclass{/home/nick/Dropbox/config/homework}"
				 ("\\section{%s}" . "\\section*{%s}")
				 ("\\subsection{%s}" . "\\subsection*{%s}")
				 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
				 ("\\paragraph{%s}" . "\\paragraph*{%s}")
				 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

  (add-to-list 'org-latex-classes
			   '("article"
				 "\\documentclass{article}"
				 ("\\section{%s}" . "\\section*{%s}")
				 ("\\subsection{%s}" . "\\subsection*{%s}")
				 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
				 ("\\paragraph{%s}" . "\\paragraph*{%s}")
				 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))



#+END_SRC

** centered previews
 #+BEGIN_SRC emacs-lisp
   ;; specify the justification you want
   (plist-put org-format-latex-options :justify 'center)

   (defun org-justify-fragment-overlay (beg end image imagetype)
	 "Adjust the justification of a LaTeX fragment.
   The justification is set by :justify in
   `org-format-latex-options'. Only equations at the beginning of a
   line are justified."
	 (cond
	  ;; Centered justification
	  ((and (eq 'center (plist-get org-format-latex-options :justify)) 
			(= beg (line-beginning-position)))
	   (let* ((img (create-image image 'imagemagick t))
			  (width (car (image-size img)))
			  ;;(offset (floor (- (/ (window-text-width) 2) (/ width 2) 15))))
			  (offset 10))
		 (overlay-put (ov-at) 'before-string (make-string offset ? ))))
	  ;; Right justification
	  ((and (eq 'right (plist-get org-format-latex-options :justify)) 
			(= beg (line-beginning-position)))
	   (let* ((img (create-image image 'imagemagick t))
			  (width (car (image-display-size (overlay-get (ov-at) 'display))))
			  (offset (floor (- (window-text-width) width (- (line-end-position) end)))))
		 (overlay-put (ov-at) 'before-string (make-string offset ? ))))))

   (defun org-latex-fragment-tooltip (beg end image imagetype)
	 "Add the fragment tooltip to the overlay and set click function to toggle it."
	 (overlay-put (ov-at) 'help-echo
				  (concat (buffer-substring beg end)
						  "mouse-1 to toggle."))
	 (overlay-put (ov-at) 'local-map (let ((map (make-sparse-keymap)))
									   (define-key map [mouse-1]
										 `(lambda ()
											(interactive)
											(org-remove-latex-fragment-image-overlays ,beg ,end)))
									   map)))

   ;; advise the function to a
   (advice-add 'org--format-latex-make-overlay :after 'org-justify-fragment-overlay)
   (advice-add 'org--format-latex-make-overlay :after 'org-latex-fragment-tooltip)
 #+END_SRC

 #+RESULTS:

* magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    ;;magit is magical git
    :ensure t
    :bind ("C-x g" . magit-status)
    :config
    (setq magit-commit-show-diff nil
          magit-revert-buffers 1))
#+END_SRC

#+RESULTS:
: magit-status

* markdown-mode
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :commands (markdown-mode gfm-mode)
  :hook (markdown-mode . linum-mode)
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :init (setq markdown-command "pandoc"))
#+END_SRC

* meghanada
#+BEGIN_SRC emacs-lisp
  ;; (use-package meghanada
  ;;   :ensure t
  ;;   :init
  ;;   (setq meghanada-gradle-path "gradle")
  ;;   :bind
  ;;   (:map meghanada-mode-map
  ;;         (("C-M-o" . meghanada-optimize-import)
  ;;          ("C-M-t" . meghanada-import-all)
  ;;          )))
  ;; (defun tkj-java-meghanda-mode-hook ()
  ;;   (meghanada-mode)
  ;;   (flycheck-mode))
  ;; (add-hook 'java-mode-hook 'tkj-java-meghanda-mode-hook)
#+END_SRC

#+RESULTS:
| tkj-java-meghanda-mode-hook | (lambda nil (gradle-mode 1)) |

* neotree
#+BEGIN_SRC emacs-lisp
  (use-package neotree
    :ensure t
    :config (setq neo-theme (if (display-graphic-p) 'icons))
    :bind ("<f8>" . neotree-project-dir-toggle))

  (defun neotree-project-dir-toggle ()
    "Open NeoTree using the project root, using find-file-in-project,
  or the current buffer directory."
    (interactive)
    (let ((project-dir
           (ignore-errors
             ;;; Pick one: projectile or find-file-in-project
                                          ; (projectile-project-root)
             (ffip-project-root)
             ))
          (file-name (buffer-file-name))
          (neo-smart-open t))
      (if (and (fboundp 'neo-global--window-exists-p)
               (neo-global--window-exists-p))
          (neotree-hide)
        (progn
          (neotree-show)
          (if project-dir
              (neotree-dir project-dir))
          (if file-name
              (neotree-find file-name))))))
#+END_SRC

#+RESULTS:
: neotree-project-dir-toggle

* org-mode
** general org stuff
#+BEGIN_SRC emacs-lisp :results silent
  (use-package org
	:ensure t
	:config
	(setq org-directory "~/Dropbox/org"
		  org-src-window-setup 'current-window
		  org-mobile-directory "~/Dropbox/Apps/MobileOrg"
		  org-mobile-files '("~/Dropbox/org")
		  org-mobile-inbox-for-pull "~/Dropbox/org/inbox.org"
		  )
	:hook (org-mode . company-mode)
	)
  (use-package org-bullets
	:ensure t
	:hook (org-mode . (lambda () (org-bullets-mode 1))))


#+END_SRC

** latex and html macro
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-src-lang-modes '("latex-macros" . latex))

  (defvar org-babel-default-header-args:latex-macros
	'((:results . "raw")
	  (:exports . "results")))

  (defun prefix-all-lines (pre body)
	(with-temp-buffer
	  (insert body)
	  (string-insert-rectangle (point-min) (point-max) pre)
	  (buffer-string)))

  (defun org-babel-execute:latex-macros (body _params)
	(concat
	 (prefix-all-lines "#+LATEX_HEADER: " body)
	 "\n#+HTML_HEAD_EXTRA: <div style=\"display: none\"> \\(\n"
	 (prefix-all-lines "#+HTML_HEAD_EXTRA: " body)
	 "\n#+HTML_HEAD_EXTRA: \\)</div>\n"))
#+END_SRC

#+RESULTS:
: org-babel-execute:latex-macros

** Don't ask to evaluate latex-macros or latex src blocks
#+BEGIN_SRC emacs-lisp
  (defun my-org-confirm-babel-evaluate (lang body)
	(not (or (string= lang "latex-macros")
			 (string= lang "latex"))))  
  (setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate)
#+END_SRC

** org-mode company completion
#+BEGIN_SRC emacs-lisp :results silent
(defun org-keyword-backend (command &optional arg &rest ignored)
  (interactive (list 'interactive))
  (cl-case command
    (interactive (company-begin-backend 'org-keyword-backend))
    (prefix (and (eq major-mode 'org-mode)
                 (cons (company-grab-line "^#\\+\\(\\w*\\)" 1)
                       t)))
    (candidates (mapcar #'upcase
                        (cl-remove-if-not
                         (lambda (c) (string-prefix-p arg c))
                         (pcomplete-completions))))
    (ignore-case t)
    (duplicates t)))
(add-to-list 'company-backends 'org-keyword-backend)
#+END_SRC



* pdf-tools
#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  ;; I like emacs, so why not view PDFs in it?  The built-in docview mode
  ;; can do so, but pdf-tools is better in all sorts of ways.

  ;; NOTE: ~pdf-tools~ only officially supports gnu/linux operating
  ;; systems. I think that it will work on macs as well, but you may have
  ;; to finagle it a bit. Regardless, I tell emacs to only use it if the OS
  ;; is linux based.
  :if (eq system-type 'gnu/linux)
  :ensure t
  :magic ("%PDF" . pdf-view-mode)
  :defer 7
  :custom
  (pdf-sync-forward-display-pdf-key "<C-return>" "Use C-RET in latex mode to jump to location in pdf file")
  (pdf-view-display-size 'fit-page "Show full pages by default instead of fitting page width.")
  (TeX-view-program-selection '((output-pdf "pdf-tools")) "Use pdf-tools to display pdfs from latex runs.")
  (TeX-view-program-list '(("pdf-tools" "TeX-pdf-tools-sync-view")))
  :config
  ;; The t says to install the server without asking me --- this may take a
  ;; second
  (pdf-tools-install t))
#+END_SRC

#+RESULTS:
: ((!#[ \t]*/.*[jp]ython[0-9.]* . python-mode) (%PDF . pdf-view-mode))

* projectile
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :hook (gradle-mode . projectile-mode))

  (use-package helm-projectile
    :ensure t
    :config
    (helm-projectile-on))
#+END_SRC

#+RESULTS:
: t

* python
#+BEGIN_SRC emacs-lisp
  (use-package anaconda-mode
    :ensure t
    :hook
    (python-mode . anaconda-mode)
    (python-mode . anaconda-eldoc-mode))

  ;;spacing around operators
  (use-package electric-operator
    :ensure t
    :hook ((ess-mode python-mode) . electric-operator-mode))

  (use-package python-mode
    :ensure t)


  ;;for autocompletion
  (use-package company-jedi
    :ensure t)
#+END_SRC

#+RESULTS:

* Texfrag
#+BEGIN_SRC emacs-lisp :results silent
  (use-package texfrag
	:ensure t
	:config
	;;(texfrag-global-mode t)
	:hook
	(org-mode . texfrag-mode)
	:diminish "Frag"
	)
#+END_SRC

* try
#+BEGIN_SRC emacs-lisp
  (use-package try
    :ensure t)
#+END_SRC

#+RESULTS:

* Undo Tree
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
	:ensure t
	:init (global-undo-tree-mode)
	:diminish
	)
#+END_SRC

#+RESULTS:
|   |

* virtualenvwrapper
#+BEGIN_SRC emacs-lisp
  (use-package virtualenvwrapper
    :ensure t
    :config
    (progn
      ;;(venv-initialize-eshell)
      (setq venv-location "~/.virtualenvs")))
#+END_SRC

* web-mode
#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :mode (("\\.html\\'" . web-mode)
           ("\\.html\\.erb\\'" . web-mode)
           ("\\.mustache\\'" . web-mode)
           ("\\.jinja\\'" . web-mode)
           ("\\.php\\'" . web-mode))
    :config
    (progn
      (setq web-mode-engines-alist
            '(("\\.jinja\\'"  . "django")))))
#+END_SRC

#+RESULTS:

* yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t)

  (use-package java-snippets
    :ensure t)
#+END_SRC

* move file
#+BEGIN_SRC emacs-lisp
  (defun move-file (new-location)
    "Write this file to NEW-LOCATION, and delete the old one."
    (interactive (list (expand-file-name
                        (if buffer-file-name
                            (read-file-name "Move file to: ")
                          (read-file-name "Move file to: "
                                          default-directory
                                          (expand-file-name (file-name-nondirectory (buffer-name))
                                                            default-directory))))))
    (when (file-exists-p new-location)
      (delete-file new-location))
    (let ((old-location (expand-file-name (buffer-file-name))))
      (message "old file is %s and new file is %s"
               old-location
               new-location)
      (write-file new-location t)
      (when (and old-location
                 (file-exists-p new-location)
                 (not (string-equal old-location new-location)))
        (delete-file old-location))))
  (bind-key "C-x C-m" #'move-file)
#+END_SRC

#+RESULTS:
: move-file

* toggle split
#+BEGIN_SRC emacs-lisp
  (defun toggle-window-split ()
    (interactive)
    (if (= (count-windows) 2)
        (let* ((this-win-buffer (window-buffer))
               (next-win-buffer (window-buffer (next-window)))
               (this-win-edges (window-edges (selected-window)))
               (next-win-edges (window-edges (next-window)))
               (this-win-2nd (not (and (<= (car this-win-edges)
                                           (car next-win-edges))
                                       (<= (cadr this-win-edges)
                                           (cadr next-win-edges)))))
               (splitter
                (if (= (car this-win-edges)
                       (car (window-edges (next-window))))
                    'split-window-horizontally
                  'split-window-vertically)))
          (delete-other-windows)
          (let ((first-win (selected-window)))
            (funcall splitter)
            (if this-win-2nd (other-window 1))
            (set-window-buffer (selected-window) this-win-buffer)
            (set-window-buffer (next-window) next-win-buffer)
            (select-window first-win)
            (if this-win-2nd (other-window 1))))))

  (global-set-key (kbd "C-x |") 'toggle-window-split)
#+END_SRC

#+RESULTS:
: toggle-window-split

* change directory
#+BEGIN_SRC emacs-lisp
;;(cd (getenv "OneDriveBash"))
#+END_SRC


* spellcheck
#+BEGIN_SRC emacs-lisp
	;; find aspell and hunspell automatically
	(cond

	 ((executable-find "aspell")
	  (setq ispell-program-name "aspell")
	  ;; Please note ispell-extra-args contains ACTUAL parameters passed to aspell
	  (setq ispell-extra-args '("--mode=tex" "-t" "--sug-mode=ultra" "--lang=en_US"))))

	(eval-after-load "flyspell"
	  '(progn
		 (define-key flyspell-mouse-map [mouse-3] #'flyspell-correct-word)))


  (defun endless/org-ispell ()
	(make-local-variable 'ispell-skip-region-alist)

	(defconst help/org-special-pre "^\s*#[+]")
	(defun help/block-regex (special)
	  "Make an ispell skip-region alist for a SPECIAL block."
	  (interactive)
	  `(,(concat help/org-special-pre "BEGIN_" special)
		.
		,(concat help/org-special-pre "END_" special)))

	(add-to-list 'ispell-skip-region-alist (help/block-regex "SRC"))
	(add-to-list 'ispell-skip-region-alist (help/block-regex "EXAMPLE"))
	(add-to-list 'ispell-skip-region-alist '("^\s*:PROPERTIES\:$" . "^\s*:END\:$"))
	(let ()
	  (--each
		  '(("ATTR_LATEX" nil)
			("AUTHOR" nil)
			("BLOG" nil)
			("CREATOR" nil)
			("DATE" nil)
			("DESCRIPTION" nil)
			("EMAIL" nil)
			("EXPORT" nil)
			("EXCLUDE_TAGS" nil)
			("HTML_CONTAINER" nil)
			("HTML_DOCTYPE" nil)
			("HTML_HEAD" nil)
			("HTML_HEAD_EXTRA" nil)
			("HTML_LINK_HOME" nil)
			("HTML_LINK_UP" nil)
			("HTML_MATHJAX" nil)
			("INFOJS_OPT" nil)
			("KEYWORDS" nil)
			("LANGUAGE" nil)
			("LATEX_CLASS" nil)
			("LATEX_CLASS_OPTIONS" nil)
			("LATEX_HEADER" nil)
			("LATEX_HEADER_EXTRA" nil)
			("NAME" t)
			("OPTIONS" t)
			("POSTID" nil)
			("RESULTS" t)
			("SELECT_TAGS" nil)
			("STARTUP" nil)
			("TITLE" nil))
		(add-to-list
		 'ispell-skip-region-alist
		 (let ((special (concat "#[+]" (car it) ":")))
		   (if (cadr it)
			   (cons special "$")
			 (list special)))))))
  (add-hook 'org-mode-hook #'endless/org-ispell)
#+END_SRC

#+RESULTS:
| endless/org-ispell | (lambda nil (org-bullets-mode 1)) | er/add-org-mode-expansions | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-show-block-all append local] 5] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-babel-show-result-all append local] 5] | org-babel-result-hide-spec | org-babel-hide-all-hashes |


* powerline
#+BEGIN_SRC emacs-lisp 
  (use-package powerline
	:ensure t
	:config 
	;;(powerline-default-theme)
	)

  (use-package spaceline
	:ensure t 
	:config
	(spaceline-emacs-theme)
	(spaceline-helm-mode)
	;;(spaceline-spacemacs-theme)
	)
#+END_SRC



#+RESULTS:

