#+STARTTIP: overview
* interface tweaks
#+BEGIN_SRC emacs-lisp
  ;;; package --- summary
  ;;; Commentary:
  ;;; Code:

  ;;disable start screen
  (setq inhibit-startup-screen t)
  (tool-bar-mode -1)

  ;;yes or no prompts to y or n
  (fset 'yes-or-no-p 'y-or-n-p)

  (global-set-key (kbd "<f5>") 'revert-buffer)

  ;;reduce clutter in init file
  (setq custom-file "~/.emacs.d/custom.el")
  (load custom-file)
  (package-initialize)

  ;; Delete my files by moving them to the trash. I'm human and
  ;; occasionally delete things that I actually want later:
  (setq delete-by-moving-to-trash t)

#+END_SRC

#+RESULTS:
: t

* scrolling
#+BEGIN_SRC emacs-lisp
  ;; Emacs has some awful scrolling by default. This gets rid of that.
  (setq scroll-step 1) ; keyboard scroll one line at a time
  (setq scroll-preserve-screen-position 'always)
  (setq scroll-conservatively 101)
  (setq next-screen-context-lines 5)

  ;;mouse scrolling

  ;; scroll one line at a time (less "jumpy" than defaults)
  (setq mouse-wheel-scroll-amount '(3 ((shift) . 1))) ;; one line at a time
  (setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
  (setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
  (setq ring-bell-function 'ignore)

#+END_SRC

* message
#+BEGIN_SRC emacs-lisp
(message "hello from init.el")
(message "hello from ubuntu")
#+END_SRC

* modes
#+BEGIN_SRC emacs-lisp
  (global-visual-line-mode t)
  (electric-pair-mode 1)
  (show-paren-mode 1)
  (set-face-attribute 'default nil :height 110)

  ;;linum-mode hooks
  (add-hook 'emacs-lisp-mode-hook 'linum-mode)
  (add-hook 'sh-mode-hook 'linum-mode)
#+END_SRC

#+RESULTS:
| linum-mode |

  
* themes
#+BEGIN_SRC emacs-lisp
  (use-package color-theme-sanityinc-tomorrow
    :ensure t)
#+END_SRC

#+RESULTS:

* don't know if this is required
#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (add-to-list 'load-path "~/.emacs.d/elpa/use-package" user-emacs-directory)
    (require 'use-package))
  (use-package diminish
    :ensure t)
  (use-package bind-key
    :ensure t)
#+END_SRC

* ace-window
#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :ensure t
    :init
    (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
    (setq aw-background nil)
    (progn
      (global-set-key [remap other-window] 'ace-window)
      (custom-set-faces
       '(aw-leading-char-face
	 ((t (:inherit ace-jump-face-foreground :height 3.0)))))
      ))

#+END_SRC

#+RESULTS:

* aggressive-indent
#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
    ;; Keep code indented automatically
    :ensure t
    :defer 10
    :config
    (global-aggressive-indent-mode))
#+END_SRC
* cdlatex
#+BEGIN_SRC emacs-lisp
  (use-package cdlatex
    :hook (LaTeX-mode . turn-on-cdlatex))
#+END_SRC

* auctex
#+BEGIN_SRC emacs-lisp
  (use-package tex-site
    ;; AuCTeX is better than the built in tex mode; let's use it.  This
    ;; demand adds almost nothing and ensures that auctex gets to set itself
    ;; up properly. That's necessary because of how weirdly it gets loaded.
    :ensure auctex
    :demand t
    :custom
    (TeX-auto-save t)
    (TeX-electric-escape t)
    (TeX-electric-math '("\\(" . "\\)") "Smart $ behavior")
    (TeX-electric-sub-and-superscript t)
    (TeX-parse-self t)
    (reftex-plug-into-AUCTeX t)
    (TeX-source-correlate-method 'synctex)
    (TeX-source-correlate-mode t)
    (TeX-clean-confirm nil)
    ;; TeX-command-list by default contains a bunch of stuff I'll never
    ;; use. I use latexmk, xelatexmk, and View.  That's pretty much it.
    ;; Maybe one day I'll add "clean" back to the list.
    ;; (TeX-command-list
    ;;  '(("latexmk" "latexmk -synctex=1 -quiet -pdf %s"
    ;;     TeX-run-compile nil t :help "Process file with latexmk")
    ;;    ("View" "%V" TeX-run-discard-or-function nil t :help "Run Viewer")
    ;;    ("xelatexmk" "latexmk -synctex=1 -quiet -xelatex %s"
    ;;     TeX-run-compile nil t :help "Process file with xelatexmk")))
    :hook
    (LaTeX-mode . LaTeX-math-mode)
    (LaTeX-mode . reftex-mode)
    (LaTeX-mode . TeX-PDF-mode)
    (LaTeX-mode . (lambda ()
		    (push
		     '("Make" "latexmk -outdir=/tmp %t" TeX-run-TeX nil t
		       :help "Make pdf output using latexmk.")
		     TeX-command-list)))
    :config
    (setq-default TeX-command-default "latexmk")
    ;; revert pdf from file after compilation finishes
    (use-package tex-buf
      :config
      (add-hook 'TeX-after-compilation-finished-functions #'TeX-revert-document-buffer))
    (use-package latex
      :bind
      (:map LaTeX-mode-map
	    ("M-p" . outline-previous-visible-heading)
	    ("M-n" . outline-next-visible-heading)
	    ("<backtab>" . org-cycle))
      :config
      (push "\\.fdb_latexmk" LaTeX-clean-intermediate-suffixes)
      (push "\\.fls" LaTeX-clean-intermediate-suffixes)
      (push "\\.synctex.gz" LaTeX-clean-intermediate-suffixes)))
#+END_SRC

* company
#+BEGIN_SRC emacs-lisp
  (use-package company
    ;; Company mode provides autocompletion of text and code.
    :ensure t  
    :bind
    (:map company-active-map
          ("C-s" . company-search-candidates)
          ("<tab>" . company-complete-common-or-cycle)
          ("RET" . company-complete-selection)
          ("C-n" . company-select-next)
          ("C-p" . company-select-previous))
    :hook
    ((prog-mode ess-mode) . company-mode)
    :config
    (defun my/python-mode-hook ()
      (add-to-list 'company-backends 'company-jedi))
    (add-hook 'python-mode-hook 'my/python-mode-hook)
    :custom
    (company-idle-delay 0.25)
    (company-require-match nil)
    (company-minimum-prefix-length 2))
#+END_SRC

#+RESULTS:
: company-select-previous
* eclim 
#+BEGIN_SRC emacs-lisp
  ;; (use-package eclim
  ;;   :ensure t
  ;;   :load-path ("~/.emacs.d/elpa/eclim-20171113.1754/")
  ;;   :init
  ;;   (progn
  ;;     (setq eclimd-autostart t
  ;;           eclim-executable "/opt/eclipse/plugins/org.eclim_2.7.2/bin/eclim"
  ;;           eclimd-executable "/opt/eclipse/plugins/org.eclim_2.7.2/bin/eclimd"
  ;;           ;;eclimd-wait-for-process t
  ;;           eclimd-default-workspace "~/my-workspace"
  ;;           eclim-eclipse-dirs "/opt/eclipse"
  ;;           help-at-pt-display-when-idle t
  ;;           help-at-pt-timer-delay 1.0
  ;;           eclim-auto-save nil
  ;;           )
  ;;     (help-at-pt-set-timer)
  ;;     )
  ;;   :hook (java-mode . eclim-mode)
  ;;   )

  ;;   (use-package company-emacs-eclim
  ;;     :ensure t
  ;;     :config (company-emacs-eclim-setup))
#+END_SRC

#+RESULTS:
: t

* exec-path-from-shell
#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :init
    (when (memq window-system '(mac ns x))
      (exec-path-from-shell-initialize)))
#+END_SRC

#+RESULTS:

* flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :init (global-flycheck-mode)
    :config 
    ;;(setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))
    )
#+END_SRC

#+RESULTS:
: t

* gradle
#+BEGIN_SRC emacs-lisp
  (use-package gradle-mode
    :ensure t
    :hook (java-mode . (lambda() (gradle-mode 1))))

  ;; (defun build-and-run (&optional CLASS-NAME)
  ;;   "Get class name from buffer."
  ;;   (interactive "sClass to run (default current buffer): ")
  ;;   (gradle-run (concat "build run -Pmain=" (or CLASS-NAME (file-name-base (buffer-file-name (window-buffer (minibuffer-selected-window))))))))

  (cl-defun build-and-run (&optional CLASS-NAME &key (CLASS-NAME (file-name-base (buffer-file-name (window-buffer (minibuffer-selected-window))))))
    (interactive "sClass to run (default current buffer): ")
    (save-buffer)
    (gradle-run (concat "build run -q -Pmain=" CLASS-NAME)))

  (define-key gradle-mode-map (kbd "C-c C-r") 'build-and-run)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp
  (use-package groovy-mode
    :ensure t
    :hook (//.gradle// . groovy-mode))
#+END_SRC

#+RESULTS:
| groovy-mode |

* Helm
#+BEGIN_SRC emacs-lisp
  ;;; Helm
  (use-package helm
    ;; A package in a league of its own: https://tuhdo.github.io/helm-intro.html
    ;; load it soon after starting Emacs:
    :ensure t
    :defer 1
    :bind
    (("M-x" . helm-M-x)
     ("C-x C-f" . helm-find-files)
     ("M-y" . helm-show-kill-ring)
     ("C-M-z" . helm-resume)
     ([remap occur] . helm-occur)
     ([remap bookmark-jump] . helm-bookmarks)
     ("C-x b" . helm-buffers-list)
     ("C-x C-b" . helm-buffers-list)
     ("M-s M-g" . helm-google-suggest)
     ("M-o" . helm-semantic-or-imenu)
     ("C-h SPC" . helm-all-mark-rings)
     ("M-s g" . helm-grep-do-git-grep)
     :map helm-map
     ("<tab>" . helm-execute-persistent-action)
     ("C-i" . helm-execute-persistent-action)
     ("C-z" . helm-select-action))
    :custom
    (helm-display-header-line nil)
    (helm-echo-input-in-header-line t)
    (helm-net-prefer-curl t)
    (helm-split-window-default-side 'below)
    (helm-split-window-inside-p t)
    (helm-command-prefix-key "M-,")
    :init
    (require 'helm-config)
    :config
    (use-package helm-files
      :config
      (push ".git$" helm-boring-file-regexp-list))
    (use-package helm-org
      :bind
      (:map my/map
            ("t" . helm-org-agenda-files-headings)))
    (helm-mode)
    (use-package helm-swoop
      :ensure t
      :config
      (progn
        (global-set-key (kbd "C-s") 'helm-swoop-without-pre-input)
        ;;(setq helm-swoop-pre-input-function  (lambda () ""))
        (setq helm-swoop-use-fuzzy-match t)
        )
      ))
#+END_SRC

#+RESULTS:
: helm-select-action

* icons and fonts
#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons
    :ensure t)
#+END_SRC
* jdee
#+BEGIN_SRC emacs-lisp
;;  (use-package jdee
  ;;  :ensure t)
#+END_SRC

#+RESULTS:

* js2
#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :ensure t
    :hook ((//.js// . js2-mode)
           (js2-mode . js2-imenu-extras-mode))
    )

  (use-package js2-refactor
    :ensure t)
#+END_SRC

#+RESULTS:

* magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    ;;magit is magical git
    :ensure t
    :bind ("C-x g" . magit-status)
    :config
    (setq magit-commit-show-diff nil
          magit-revert-buffers 1))
#+END_SRC

#+RESULTS:
: magit-status

* markdown-mode
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :commands (markdown-mode gfm-mode)
  :hook (markdown-mode . linum-mode)
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :init (setq markdown-command "pandoc"))
#+END_SRC

* meghanada
#+BEGIN_SRC emacs-lisp
  (use-package meghanada
    :ensure t
    :init
    (setq meghanada-gradle-path "gradle")
    :bind
    (:map meghanada-mode-map
          (("C-M-o" . meghanada-optimize-import)
           ("C-M-t" . meghanada-import-all)
           )))
  (defun tkj-java-meghanda-mode-hook ()
    (meghanada-mode)
    (flycheck-mode))
  (add-hook 'java-mode-hook 'tkj-java-meghanda-mode-hook)
#+END_SRC

#+RESULTS:
| tkj-java-meghanda-mode-hook | (lambda nil (gradle-mode 1)) |

* neotree
#+BEGIN_SRC emacs-lisp
  (use-package neotree
    :ensure t
    :config (setq neo-theme (if (display-graphic-p) 'icons))
    :bind ("<f8>" . neotree-project-dir-toggle))

  (defun neotree-project-dir-toggle ()
    "Open NeoTree using the project root, using find-file-in-project,
  or the current buffer directory."
    (interactive)
    (let ((project-dir
           (ignore-errors
             ;;; Pick one: projectile or find-file-in-project
                                          ; (projectile-project-root)
             (ffip-project-root)
             ))
          (file-name (buffer-file-name))
          (neo-smart-open t))
      (if (and (fboundp 'neo-global--window-exists-p)
               (neo-global--window-exists-p))
          (neotree-hide)
        (progn
          (neotree-show)
          (if project-dir
              (neotree-dir project-dir))
          (if file-name
              (neotree-find file-name))))))
#+END_SRC

#+RESULTS:
: neotree-project-dir-toggle

* org-mode
#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure t
    :config
    (setq org-src-window-setup 'current-window)
    )
    (use-package org-bullets
      :ensure t
      :hook (org-mode . (lambda () (org-bullets-mode 1))))
#+END_SRC
* pdf-tools
#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  ;; I like emacs, so why not view PDFs in it?  The built-in docview mode
  ;; can do so, but pdf-tools is better in all sorts of ways.

  ;; NOTE: ~pdf-tools~ only officially supports gnu/linux operating
  ;; systems. I think that it will work on macs as well, but you may have
  ;; to finagle it a bit. Regardless, I tell emacs to only use it if the OS
  ;; is linux based.
  :if (eq system-type 'gnu/linux)
  :ensure t
  :magic ("%PDF" . pdf-view-mode)
  :defer 7
  :custom
  (pdf-sync-forward-display-pdf-key "<C-return>" "Use C-RET in latex mode to jump to location in pdf file")
  (pdf-view-display-size 'fit-page "Show full pages by default instead of fitting page width.")
  (TeX-view-program-selection '((output-pdf "pdf-tools")) "Use pdf-tools to display pdfs from latex runs.")
  (TeX-view-program-list '(("pdf-tools" "TeX-pdf-tools-sync-view")))
  :config
  ;; The t says to install the server without asking me --- this may take a
  ;; second
  (pdf-tools-install t))
#+END_SRC

* projectile
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :hook (gradle-mode . projectile-mode))

  (use-package helm-projectile
    :ensure t
    :config
    (helm-projectile-on))
#+END_SRC

#+RESULTS:
: t

* python
#+BEGIN_SRC emacs-lisp
  (use-package anaconda-mode
    :ensure t
    :hook
    (python-mode . anaconda-mode)
    (python-mode . anaconda-eldoc-mode))

  ;;spacing around operators
  (use-package electric-operator
    :ensure t
    :hook ((ess-mode python-mode) . electric-operator-mode))

  (use-package python-mode
    :ensure t)


  ;;for autocompletion
  (use-package company-jedi
    :ensure t)
#+END_SRC

#+RESULTS:

* try
#+BEGIN_SRC emacs-lisp
  (use-package try
    :ensure t)
#+END_SRC

#+RESULTS:

* virtualenvwrapper
#+BEGIN_SRC emacs-lisp
  (use-package virtualenvwrapper
    :ensure t
    :config
    (progn
      ;;(venv-initialize-eshell)
      (setq venv-location "~/.virtualenvs")))
#+END_SRC

* web-mode
#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :mode (("\\.html\\'" . web-mode)
           ("\\.html\\.erb\\'" . web-mode)
           ("\\.mustache\\'" . web-mode)
           ("\\.jinja\\'" . web-mode)
           ("\\.php\\'" . web-mode))
    :config
    (progn
      (setq web-mode-engines-alist
            '(("\\.jinja\\'"  . "django")))))
#+END_SRC

#+RESULTS:

* move file
#+BEGIN_SRC emacs-lisp
  (defun move-file (new-location)
    "Write this file to NEW-LOCATION, and delete the old one."
    (interactive (list (expand-file-name
                        (if buffer-file-name
                            (read-file-name "Move file to: ")
                          (read-file-name "Move file to: "
                                          default-directory
                                          (expand-file-name (file-name-nondirectory (buffer-name))
                                                            default-directory))))))
    (when (file-exists-p new-location)
      (delete-file new-location))
    (let ((old-location (expand-file-name (buffer-file-name))))
      (message "old file is %s and new file is %s"
               old-location
               new-location)
      (write-file new-location t)
      (when (and old-location
                 (file-exists-p new-location)
                 (not (string-equal old-location new-location)))
        (delete-file old-location))))
  (bind-key "C-x C-m" #'move-file)
#+END_SRC

#+RESULTS:
: move-file

* toggle split
#+BEGIN_SRC emacs-lisp
  (defun toggle-window-split ()
    (interactive)
    (if (= (count-windows) 2)
        (let* ((this-win-buffer (window-buffer))
               (next-win-buffer (window-buffer (next-window)))
               (this-win-edges (window-edges (selected-window)))
               (next-win-edges (window-edges (next-window)))
               (this-win-2nd (not (and (<= (car this-win-edges)
                                           (car next-win-edges))
                                       (<= (cadr this-win-edges)
                                           (cadr next-win-edges)))))
               (splitter
                (if (= (car this-win-edges)
                       (car (window-edges (next-window))))
                    'split-window-horizontally
                  'split-window-vertically)))
          (delete-other-windows)
          (let ((first-win (selected-window)))
            (funcall splitter)
            (if this-win-2nd (other-window 1))
            (set-window-buffer (selected-window) this-win-buffer)
            (set-window-buffer (next-window) next-win-buffer)
            (select-window first-win)
            (if this-win-2nd (other-window 1))))))

  (global-set-key (kbd "C-x |") 'toggle-window-split)
#+END_SRC

#+RESULTS:
: toggle-window-split

* change directory
#+BEGIN_SRC emacs-lisp
(cd (getenv "OneDriveBash"))
#+END_SRC

