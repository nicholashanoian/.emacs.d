#+STARTTIP: overview

* don't know if this is required
#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (add-to-list 'load-path "~/.emacs.d/elpa/use-package" user-emacs-directory)
    (require 'use-package))
  (use-package diminish
    :ensure t)
  (use-package bind-key
    :ensure t)
#+END_SRC
* interface tweaks
#+BEGIN_SRC emacs-lisp
      ;;; package --- summary
      ;;; Commentary:
      ;;; Code:

  ;;disable start screen
  (setq inhibit-startup-screen t)
  (tool-bar-mode -1)

  ;;yes or no prompts to y or n
  (fset 'yes-or-no-p 'y-or-n-p)

  (global-set-key (kbd "<f5>") 'revert-buffer)

  ;;reduce clutter in init file
  (setq custom-file "~/.emacs.d/custom.el")
  (load custom-file)
  ;;(package-initialize)

  ;; Delete my files by moving them to the trash. I'm human and
  ;; occasionally delete things that I actually want later:
  (setq delete-by-moving-to-trash t)
  (setq display-time-mode 1
        fringe-mode 0)

  ;;supposedly makes emacs snappier
  (add-hook 'focus-out-hook #'garbage-collect)

  ;;removes menubar when in terminal
  ;; (defun contextual-menubar (&optional frame)
  ;;   "Display the menubar in FRAME (default: selected frame) if on a
  ;;     graphical display, but hide it if in terminal."
  ;;   (interactive)
  ;;   (set-frame-parameter frame 'menu-bar-lines 
  ;;                        (if (display-graphic-p frame)
  ;;                            1 0)))
  ;; (add-hook 'after-make-frame-functions 'contextual-menubar)

  ;;remove menubar
  (menu-bar-mode -1)


  ;;(set-default-font "DejaVu Sans Mono");; Set default font
  (set-face-attribute 'default nil
                      :family "DejaVu Sans Mono"
                      :height 120
                      :weight 'normal
                      :width 'normal)

  ;;focuse follows mouse
  (setq mouse-autoselect-window t)

  ;;store backups here
(defvar backup-dir "~/.emacs.d/backups/")
;;(setq backup-directory-alist backup-dir)
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))

#+END_SRC

#+RESULTS:

* scrolling
#+BEGIN_SRC emacs-lisp
  ;; Emacs has some awful scrolling by default. This gets rid of that.
  (setq scroll-step 1) ; keyboard scroll one line at a time
  (setq scroll-preserve-screen-position 'always)
  (setq scroll-conservatively 101)
  (setq next-screen-context-lines 5)

  ;;mouse scrolling

  ;; scroll one line at a time (less "jumpy" than defaults)
  (setq mouse-wheel-scroll-amount '(3 ((shift) . 1))) ;; one line at a time
  (setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
  (setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
  (setq ring-bell-function 'ignore)

#+END_SRC

* message
#+BEGIN_SRC emacs-lisp
(message "hello from init.el")
(message "hello from ubuntu")
#+END_SRC

* modes
#+BEGIN_SRC emacs-lisp
  (scroll-bar-mode 0)  
  (global-visual-line-mode t)
  (diminish 'visual-line-mode)
  (diminish 'eldoc-mode)
  (global-hl-line-mode t)
  (electric-pair-mode 1)
  (show-paren-mode 1) 
  (set-face-attribute 'default nil :height 110)
  (pending-delete-mode 1)

  ;;save outside clipboard to kill ring
  (setq save-interprogram-paste-before-kill t)


  ;;linum-mode hooks
  (add-hook 'emacs-lisp-mode-hook 'linum-mode)
  (add-hook 'sh-mode-hook 'linum-mode)




  ;;evaluate and replace
  (defun eval-and-replace ()
	"Replace the preceding sexp with its value."
	(interactive)
	(backward-kill-sexp)
	(condition-case nil
		(prin1 (eval (read (current-kill 0)))
			   (current-buffer))
	  (error (message "Invalid expression")
			 (insert (current-kill 0)))))
  (global-set-key (kbd "C-x M-e") 'eval-and-replace)


  ;;open config
  (define-key global-map (kbd "\e\ec")  (lambda () (interactive) (find-file "~/.emacs.d/myinit.org")))
#+END_SRC

#+RESULTS:
| lambda | nil | (interactive) | (find-file ~/.emacs.d/myinit.org) |

* ibuffer
#+BEGIN_SRC emacs-lisp
	(use-package ibuffer
	  :ensure t
	  :config
	  (global-set-key (kbd "C-x C-b") 'ibuffer)
	  (setq ibuffer-saved-filter-groups
			(quote (("default"
					 ("dired" (mode . dired-mode))
					 ("org" (name . "^.*org$"))
					 ("web" (or (mode . web-mode) (mode . js2-mode)))
					 ("shell" (or (mode . eshell-mode) (mode . shell-mode)))
					 ("mu4e" (name . "\*mu4e\*"))
					 ("programming" (or
									 (mode . python-mode)
									 (mode . c++-mode)))
					 ("emacs" (or
							   (name . "^\\*scratch\\*$")
							   (name . "^\\*Messages\\*$")))
					 ))))
	  (add-hook 'ibuffer-mode-hook
				(lambda ()
				  (ibuffer-auto-mode 1)
				  (ibuffer-switch-to-saved-filter-groups "default")))

	  ;; don't show these

	  ;; Don't show filter groups if there are no buffers in that group
	  (setq ibuffer-show-empty-filter-groups nil)
  
	  ;; Don't ask for confirmation to delete marked buffers
	  (setq ibuffer-expert t)
	  (setq ibuffer-never-show-predicates '("helm"))
	  )
#+END_SRC

#+RESULTS:
: t
  
* themes
#+BEGIN_SRC emacs-lisp
  (use-package color-theme-sanityinc-tomorrow
	:ensure t
	:defer t)
  (use-package solarized-theme
	:ensure t
	:defer t)
  (use-package zenburn-theme
	:ensure t
	:defer t)
  (use-package material-theme
	:ensure t
	:defer t)
  #+END_SRC

#+RESULTS:

* hydra
#+BEGIN_SRC emacs-lisp
  (use-package hydra
	:ensure t)
#+END_SRC

#+RESULTS:
* ace-window
#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :ensure t
    :init
    (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
    (setq aw-background nil)
    (progn
      (global-set-key [remap other-window] 'ace-window)
      (custom-set-faces
       '(aw-leading-char-face
         ((t (:inherit ace-jump-face-foreground :height 3.0)))))
      )
    (define-key global-map (kbd "C-x \\") 'ace-swap-window)
    )

#+END_SRC

#+RESULTS:

* avy
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :config
    (setq ;; avy-keys
          ;; (nconc (number-sequence ?a ?z)
          ;;        ;;(number-sequence ?A ?Z)
          ;;        )
          avy-background t
          avy-all-windows nil
          )
    :bind
    (("M-g g" . avy-goto-line)
     ("M-g w" . avy-goto-word-or-subword-1)
     

     )
    )
#+END_SRC

#+RESULTS:
: avy-goto-word-or-subword-1

* aggressive-indent
#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
	;; Keep code indented automatically
	:ensure t
	:defer 10
	:config
	(global-aggressive-indent-mode)
	:diminish)
#+END_SRC

#+RESULTS:
: t

* auctex
#+BEGIN_SRC emacs-lisp :results output silent 
  (use-package tex-site
	;; AuCTeX is better than the built in tex mode; let's use it.  This
	;; demand adds almost nothing and ensures that auctex gets to set itself
	;; up properly. That's necessary because of how weirdly it gets loaded.
	:ensure auctex
	:demand t
	:custom
	(TeX-auto-save t)
	;;(TeX-electric-escape t)
	(TeX-electric-math '("\\(" . "\\)") "Smart $ behavior")
	(TeX-electric-sub-and-superscript t)
	(TeX-parse-self t)
	(reftex-plug-into-AUCTeX t)
	;;(setq font-latex-fontify-script nil) ;; stop changing position of stuff on lines
	(TeX-source-correlate-method 'synctex)
	(TeX-source-correlate-mode t)
	(TeX-clean-confirm nil)
	;; TeX-command-list by default contains a bunch of stuff I'll never
	;; use. I use latexmk, xelatexmk, and View.  That's pretty much it.
	;; Maybe one day I'll add "clean" back to the list.
	;; (TeX-command-list
	;;  '(("latexmk" "latexmk -synctex=1 -quiet -pdf %s"
	;;     TeX-run-compile nil t :help "Process file with latexmk")
	;;    ("View" "%V" TeX-run-discard-or-function nil t :help "Run Viewer")
	;;    ("xelatexmk" "latexmk -synctex=1 -quiet -xelatex %s"
	;;     TeX-run-compile nil t :help "Process file with xelatexmk")))
	:hook
	(LaTeX-mode . LaTeX-math-mode)
	(LaTeX-mode . reftex-mode)
	(LaTeX-mode . TeX-PDF-mode)
	(LaTeX-mode . (lambda ()
					(push
					 '("Make" "latexmk -outdir=/tmp %t" TeX-run-TeX nil t
					   :help "Make pdf output using latexmk.")
					 TeX-command-list)))
	:config
	(setq-default TeX-command-default "latexmk")
	;; revert pdf from file after compilation finishes
	(use-package tex-buf
	  :config
	  (add-hook 'TeX-after-compilation-finished-functions #'TeX-revert-document-buffer))
	(use-package latex
	  :bind
	  (:map LaTeX-mode-map
			("M-p" . outline-previous-visible-heading)
			("M-n" . outline-next-visible-heading)
			("<backtab>" . org-cycle))
	  :config
	  (push "\\.fdb_latexmk" LaTeX-clean-intermediate-suffixes)
	  (push "\\.fls" LaTeX-clean-intermediate-suffixes)
	  (push "\\.synctex.gz" LaTeX-clean-intermediate-suffixes)))
#+END_SRC

#+RESULTS:
| japanese-latex-mode-initialization | er/add-latex-mode-expansions | (lambda nil (push '(Make latexmk -outdir=/tmp %t TeX-run-TeX nil t :help Make pdf output using latexmk.) TeX-command-list)) | preview-mode-setup | (lambda nil (setq TeX-command-list (cons '(Make latexmk -outdir=/tmp %t TeX-run-TeX nil t :help Make pdf output using latexmk.) TeX-command-list))) | TeX-PDF-mode | reftex-mode | LaTeX-math-mode | turn-on-cdlatex |

* Beacon mode
#+BEGIN_SRC emacs-lisp
  ;;   ;; flashes the cursor's line when you scroll
  ;;   (use-package beacon
  ;; 	:ensure t
  ;; 	:config (beacon-mode 1)
  ;; )
#+END_SRC

#+RESULTS:
: t

* cdlatex
#+BEGIN_SRC emacs-lisp
  (use-package cdlatex
	:ensure t
	:hook ((LaTeX-mode . turn-on-cdlatex)
		   ;;(org-mode . turn-on-cdlatex)
)
	)
#+END_SRC

#+RESULTS:
| preview-mode-setup | er/add-latex-mode-expansions | turn-on-cdlatex | (lambda nil (setq TeX-command-list (cons '(Make latexmk -outdir=/tmp %t TeX-run-TeX nil t :help Make pdf output using latexmk.) TeX-command-list))) | TeX-PDF-mode | reftex-mode | LaTeX-math-mode |

* company
#+BEGIN_SRC emacs-lisp
  (use-package company
    ;; Company mode provides autocompletion of text and code.
    :ensure t  
    :bind
    (:map company-active-map
          ("C-s" . company-search-candidates)
          ("<tab>" . company-complete-common-or-cycle)
          ("RET" . company-complete-selection)
          ("C-n" . company-select-next)
          ("C-p" . company-select-previous))
    :hook
    ((prog-mode ess-mode) . company-mode)
    :config
    ;; (defun my/python-mode-hook ()
    ;;   (add-to-list 'company-backends 'company-jedi))
    ;; (add-hook 'python-mode-hook 'my/python-mode-hook)
    :custom
    (company-idle-delay 0.25)
    (company-require-match nil)
    (company-minimum-prefix-length 2)
    :diminish "Company"
    )
#+END_SRC

#+RESULTS:
: company-select-previous

* eclim 
#+BEGIN_SRC emacs-lisp
  ;; (use-package eclim
  ;;   :ensure t
  ;;   :load-path ("~/.emacs.d/elpa/eclim-20171113.1754/")
  ;;   :init
  ;;   (progn
  ;;     (setq eclimd-autostart t
  ;;           eclim-executable "/opt/eclipse/plugins/org.eclim_2.7.2/bin/eclim"
  ;;           eclimd-executable "/opt/eclipse/plugins/org.eclim_2.7.2/bin/eclimd"
  ;;           ;;eclimd-wait-for-process t
  ;;           eclimd-default-workspace "~/my-workspace"
  ;;           eclim-eclipse-dirs "/opt/eclipse"
  ;;           help-at-pt-display-when-idle t
  ;;           help-at-pt-timer-delay 1.0
  ;;           eclim-auto-save nil
  ;;           )
  ;;     (help-at-pt-set-timer)
  ;;     )
  ;;   :hook (java-mode . eclim-mode)
  ;;   )

  ;;   (use-package company-emacs-eclim
  ;;     :ensure t
  ;;     :config (company-emacs-eclim-setup))
#+END_SRC

#+RESULTS:
: t

* exec-path-from-shell
#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :init
    (when (memq window-system '(mac ns x))
      (exec-path-from-shell-initialize)))
#+END_SRC

#+RESULTS:
* Expand region
#+BEGIN_SRC emacs-lisp
  ;; expand the marked region in semantic increments (negative prefix to reduce region)
  (use-package expand-region
	:ensure t
	:config 
	(global-set-key (kbd "C-=") 'er/expand-region))
#+END_SRC

#+RESULTS:
: t

* flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :init (global-flycheck-mode)
    :config 
	:diminish "FlyC"
    ;;(setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))
	;;:diminish
    )
#+END_SRC

#+RESULTS:
| FlyC |
|      |
* flyspell
#+BEGIN_SRC emacs-lisp
  (use-package flyspell
  :ensure t
  :diminish "FlyS")
#+END_SRC

#+RESULTS:
| FlyS |

* gradle
#+BEGIN_SRC emacs-lisp
  (use-package gradle-mode
	:ensure t
	:hook (java-mode . (lambda() (gradle-mode 1))))

  ;; (defun build-and-run (&optional CLASS-NAME)
  ;;   "Get class name from buffer."
  ;;   (interactive "sClass to run (default current buffer): ")
  ;;   (gradle-run (concat "build run -Pmain=" (or CLASS-NAME (file-name-base (buffer-file-name (window-buffer (minibuffer-selected-window))))))))

  (cl-defun build-and-run (&optional CLASS-NAME &key (CLASS-NAME (file-name-base (buffer-file-name (window-buffer (minibuffer-selected-window))))))
	(interactive "sClass to run (default current buffer): ")
	(save-buffer)
	(gradle-run (concat "build run -q -Pmain=" CLASS-NAME)))

  (define-key gradle-mode-map (kbd "C-c C-r") 'build-and-run)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp
  (use-package groovy-mode
    :ensure t
    :hook (//.gradle// . groovy-mode))
#+END_SRC

#+RESULTS:
| groovy-mode |

* Helm
#+BEGIN_SRC emacs-lisp
  ;;; Helm
  (use-package helm
    ;; A package in a league of its own: https://tuhdo.github.io/helm-intro.html
    ;; load it soon after starting Emacs:
    :ensure t
    :defer 1
    :bind
    (("M-x" . helm-M-x)
     ("C-x C-f" . helm-find-files)
     ("M-y" . helm-show-kill-ring)
     ("C-M-z" . helm-resume)
     ([remap occur] . helm-occur)
     ([remap bookmark-jump] . helm-bookmarks)
     ("C-x b" . helm-buffers-list)
     ;;("C-x C-b" . helm-buffers-list) ;;replaced by ibuffer
     ("M-s M-g" . helm-google-suggest)
     ("M-o" . helm-semantic-or-imenu)
     ("C-h SPC" . helm-all-mark-rings)
     ("M-s g" . helm-grep-do-git-grep)
     :map helm-map
     ("<tab>" . helm-execute-persistent-action)
     ("C-i" . helm-execute-persistent-action)
     ("C-z" . helm-select-action))
    :custom
    (helm-display-header-line nil)
    (helm-echo-input-in-header-line t)
    (helm-net-prefer-curl t)
    (helm-split-window-default-side 'below)
    (helm-split-window-inside-p t)
    (helm-command-prefix-key "M-,")
    :init
    (require 'helm-config)
    :config
    (use-package helm-files
      :config
      (push ".git$" helm-boring-file-regexp-list))
    (use-package helm-org
      :bind
      (:map my/map
            ("t" . helm-org-agenda-files-headings)))
    (helm-mode)
    (use-package helm-swoop
      :ensure t
      :config
      (progn
        (global-set-key (kbd "C-s") 'helm-swoop-without-pre-input)
        ;;(setq helm-swoop-pre-input-function  (lambda () ""))
        (setq helm-swoop-use-fuzzy-match nil)
        )
      )
	  :diminish)
#+END_SRC

#+RESULTS:
: helm-select-action

* Hungry Delete
#+BEGIN_SRC emacs-lisp
  ;; deletes all the whitespace when you hit backspace or delete
  (use-package hungry-delete
	:ensure t
	:config
	(global-hungry-delete-mode)
	:diminish)
#+END_SRC

#+RESULTS:
: t

* icons and fonts
#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons
	:ensure t)
#+END_SRC

* jdee
#+BEGIN_SRC emacs-lisp
  ;;  (use-package jdee
	;;  :ensure t)
#+END_SRC

#+RESULTS:

* js2
#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :ensure t
    :hook ((//.js// . js2-mode)
           (js2-mode . js2-imenu-extras-mode))
    )

  (use-package js2-refactor
    :ensure t)
#+END_SRC

#+RESULTS:

* latex
#+BEGIN_SRC emacs-lisp :results output silent
    ;; My custom LaTeX class for Org-mode export. require is needed for it to work.
    ;;(setf org-highlight-latex-and-related '(latex))
    (setq org-src-fontify-natively t)
    (setq org-latex-with-hyperref nil)
    (setq org-latex-title-command "\\maketitle")
    (setq org-latex-toc-command "")
    (setq org-export-with-section-numbers nil)
    (setq user-full-name "Nicholas Hanoian")
    (setq org-latex-create-formula-image-program 'imagemagick)
    (setq org-format-latex-options (plist-put org-format-latex-options :scale 2.0))
    (setq org-latex-default-class "homework")
    (setq preview-button-1 '[mouse-1])

    (setq font-latex-fontify-script nil)
    (setq font-latex-fontify-sectioning 'color)



    ;; (defvar texfrag-submap
    ;;  '(let ((map (make-sparse-keymap)))
    ;;   (define-key map "\C-p" #'preview-at-point)
    ;;   (define-key map "\C-r" #'preview-region)
    ;;   (define-key map "\C-b" #'preview-buffer)
    ;;   (define-key map "\C-d" #'preview-document)
    ;;   (define-key map "\C-f" #'preview-cache-preamble)
    ;;   (define-key map "\C-c\C-f" #'preview-cache-preamble-off)
    ;;   (define-key map "\C-i" #'preview-goto-info-page)
    ;;   ;;  (define-key map "\C-q" #'preview-paragraph)
    ;;   (define-key map "\C-e" #'preview-environment)
    ;;   (define-key map "\C-s" #'preview-section)
    ;;   (define-key map "\C-w" #'preview-copy-region-as-mml)
    ;;   (define-key map "\C-c\C-p" #'preview-clearout-at-point)
    ;;   (define-key map "\C-c\C-r" #'preview-clearout)
    ;;   (define-key map "\C-c\C-s" #'preview-clearout-section)
    ;;   (define-key map "\C-c\C-b" #'preview-clearout-buffer)
    ;;   (define-key map "\C-c\C-d" #'preview-clearout-document)
    ;;   map))

    ;;   (texfrag-set-prefix "\C-c\C-p")

    (use-package ov
      :ensure t)

    (unless (boundp 'org-latex-classes)
      (setq org-latex-classes nil))

    (add-to-list 'org-latex-classes
                 '("homework"
                   "\\ProvidesPackage{/home/nick/Dropbox/config/homework}
  \\documentclass{/home/nick/Dropbox/config/homework}"
                   ("\\section{%s}" . "\\section*{%s}")
                   ("\\subsection{%s}" . "\\subsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\paragraph{%s}" . "\\paragraph*{%s}")
                   ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

    (add-to-list 'org-latex-classes
                 '("article"
                   "\\documentclass{article}"
                   ("\\section{%s}" . "\\section*{%s}")
                   ("\\subsection{%s}" . "\\subsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\paragraph{%s}" . "\\paragraph*{%s}")
                   ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))



#+END_SRC

** centered previews
 #+BEGIN_SRC emacs-lisp
   ;; specify the justification you want
   (plist-put org-format-latex-options :justify 'center)

   (defun org-justify-fragment-overlay (beg end image imagetype)
	 "Adjust the justification of a LaTeX fragment.
   The justification is set by :justify in
   `org-format-latex-options'. Only equations at the beginning of a
   line are justified."
	 (cond
	  ;; Centered justification
	  ((and (eq 'center (plist-get org-format-latex-options :justify)) 
			(= beg (line-beginning-position)))
	   (let* ((img (create-image image 'imagemagick t))
			  (width (car (image-size img)))
			  ;;(offset (floor (- (/ (window-text-width) 2) (/ width 2) 15))))
			  (offset 10))
		 (overlay-put (ov-at) 'before-string (make-string offset ? ))))
	  ;; Right justification
	  ((and (eq 'right (plist-get org-format-latex-options :justify)) 
			(= beg (line-beginning-position)))
	   (let* ((img (create-image image 'imagemagick t))
			  (width (car (image-display-size (overlay-get (ov-at) 'display))))
			  (offset (floor (- (window-text-width) width (- (line-end-position) end)))))
		 (overlay-put (ov-at) 'before-string (make-string offset ? ))))))

   (defun org-latex-fragment-tooltip (beg end image imagetype)
	 "Add the fragment tooltip to the overlay and set click function to toggle it."
	 (overlay-put (ov-at) 'help-echo
				  (concat (buffer-substring beg end)
						  "mouse-1 to toggle."))
	 (overlay-put (ov-at) 'local-map (let ((map (make-sparse-keymap)))
									   (define-key map [mouse-1]
										 `(lambda ()
											(interactive)
											(org-remove-latex-fragment-image-overlays ,beg ,end)))
									   map)))

   ;; advise the function to a
   (advice-add 'org--format-latex-make-overlay :after 'org-justify-fragment-overlay)
   (advice-add 'org--format-latex-make-overlay :after 'org-latex-fragment-tooltip)
 #+END_SRC

 #+RESULTS:

* magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    ;;magit is magical git
    :ensure t
    :bind ("C-x g" . magit-status)
    :config
    (setq magit-commit-show-diff nil
          magit-revert-buffers 1))
#+END_SRC

#+RESULTS:
: magit-status

* markdown-mode
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :commands (markdown-mode gfm-mode)
  :hook (markdown-mode . linum-mode)
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :init (setq markdown-command "pandoc"))
#+END_SRC

* meghanada
#+BEGIN_SRC emacs-lisp
  ;; (use-package meghanada
  ;;   :ensure t
  ;;   :init
  ;;   (setq meghanada-gradle-path "gradle")
  ;;   :bind
  ;;   (:map meghanada-mode-map
  ;;         (("C-M-o" . meghanada-optimize-import)
  ;;          ("C-M-t" . meghanada-import-all)
  ;;          )))
  ;; (defun tkj-java-meghanda-mode-hook ()
  ;;   (meghanada-mode)
  ;;   (flycheck-mode))
  ;; (add-hook 'java-mode-hook 'tkj-java-meghanda-mode-hook)
#+END_SRC

#+RESULTS:
| tkj-java-meghanda-mode-hook | (lambda nil (gradle-mode 1)) |

* neotree
#+BEGIN_SRC emacs-lisp
  (use-package neotree
    :ensure t
    :config (setq neo-theme (if (display-graphic-p) 'icons))
    :bind ("<f8>" . neotree-project-dir-toggle))

  (defun neotree-project-dir-toggle ()
    "Open NeoTree using the project root, using find-file-in-project,
  or the current buffer directory."
    (interactive)
    (let ((project-dir
           (ignore-errors
             ;;; Pick one: projectile or find-file-in-project
                                          ; (projectile-project-root)
             (ffip-project-root)
             ))
          (file-name (buffer-file-name))
          (neo-smart-open t))
      (if (and (fboundp 'neo-global--window-exists-p)
               (neo-global--window-exists-p))
          (neotree-hide)
        (progn
          (neotree-show)
          (if project-dir
              (neotree-dir project-dir))
          (if file-name
              (neotree-find file-name))))))
#+END_SRC

#+RESULTS:
: neotree-project-dir-toggle

* org-mode
** general org stuff
#+BEGIN_SRC emacs-lisp :results silent
  (use-package org
	:ensure t
	:config
	(setq org-directory "~/Dropbox/org"
		  org-src-window-setup 'current-window
		  org-mobile-directory "~/Dropbox/Apps/MobileOrg"
		  org-mobile-files '("~/Dropbox/org")
		  org-mobile-inbox-for-pull "~/Dropbox/org/inbox.org"
		  )
	(setq org-latex-caption-above nil)
	:hook ((org-mode . company-mode)
		   (org-mode . visual-line-mode))
	)
  (use-package org-bullets
	:ensure t
	:hook (org-mode . (lambda () (org-bullets-mode 1))))


  ;; (defun my-org-latex-export-to-pdf ()
  ;;   (interactive)
  ;;   (save-buffer)
  ;;   (org-latex-export-to-pdf)
  ;;   )
#+END_SRC

** latex and html macro
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-src-lang-modes '("latex-macros" . latex))

  (defvar org-babel-default-header-args:latex-macros
	'((:results . "raw")
	  (:exports . "results")))

  (defun prefix-all-lines (pre body)
	(with-temp-buffer
	  (insert body)
	  (string-insert-rectangle (point-min) (point-max) pre)
	  (buffer-string)))

  (defun org-babel-execute:latex-macros (body _params)
	(concat
	 (prefix-all-lines "#+LATEX_HEADER: " body)
	 "\n#+HTML_HEAD_EXTRA: <div style=\"display: none\"> \\(\n"
	 (prefix-all-lines "#+HTML_HEAD_EXTRA: " body)
	 "\n#+HTML_HEAD_EXTRA: \\)</div>\n"))
#+END_SRC

#+RESULTS:
: org-babel-execute:latex-macros

** Don't ask to evaluate latex-macros or latex src blocks
#+BEGIN_SRC emacs-lisp
  (defun my-org-confirm-babel-evaluate (lang body)
	(not (or (string= lang "latex-macros")
			 (string= lang "latex"))))  
  (setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate)
#+END_SRC

** org-mode company completion
#+BEGIN_SRC emacs-lisp
	(defun org-keyword-backend (command &optional arg &rest ignored)
	  (interactive (list 'interactive))
	  (cl-case command
		(interactive (company-begin-backend 'org-keyword-backend))
		(prefix (and (eq major-mode 'org-mode)
					 (cons (company-grab-line "^#\\+\\(\\w*\\)" 1)
						   t)))
		(candidates (mapcar #'upcase
							(cl-remove-if-not
							 (lambda (c) (string-prefix-p arg c))
							 (pcomplete-completions))))
		(ignore-case t)
		(duplicates t)))

  (defun my-org-mode-hook ()
	(add-to-list 'company-backends 'org-keyword-backend))
	 (add-hook 'org-mode-hook 'my-org-mode-hook)

#+END_SRC

#+RESULTS:
: org-keyword-backend


** toggle latex export on save
#+BEGIN_SRC emacs-lisp
  (defun toggle-latex-export-on-save ()
	"Enable or disable export LATEX when saving current buffer."
	(interactive)
	(when (not (eq major-mode 'org-mode))
	  (error "Not an org-mode file!"))
	(if (memq 'org-latex-export-to-pdf after-save-hook)
		(progn (remove-hook 'after-save-hook 'org-latex-export-to-pdf t)
			   (message "Disabled org latex export on save"))
	  (add-hook 'after-save-hook 'org-latex-export-to-pdf nil t)
	  (set-buffer-modified-p t)
	  (message "Enabled org latex export on save")))
  (define-key org-mode-map (kbd "C-c l") 'toggle-latex-export-on-save)
#+END_SRC

* pdf-tools
#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools
	;; I like emacs, so why not view PDFs in it?  The built-in docview mode
	;; can do so, but pdf-tools is better in all sorts of ways.

	;; NOTE: ~pdf-tools~ only officially supports gnu/linux operating
	;; systems. I think that it will work on macs as well, but you may have
	;; to finagle it a bit. Regardless, I tell emacs to only use it if the OS
	;; is linux based.
	:if (eq system-type 'gnu/linux)
	:ensure t
	:magic ("%PDF" . pdf-view-mode)
	:defer 7
	:custom
	(pdf-sync-forward-display-pdf-key "<C-return>" "Use C-RET in latex mode to jump to location in pdf file")
	(pdf-view-display-size 'fit-page "Show full pages by default instead of fitting page width.")
	(TeX-view-program-selection '((output-pdf "pdf-tools")) "Use pdf-tools to display pdfs from latex runs.")
	(TeX-view-program-list '(("pdf-tools" "TeX-pdf-tools-sync-view")))
	:config
	;; The t says to install the server without asking me --- this may take a
	;; second
	(pdf-tools-install t))
#+END_SRC

#+RESULTS:
: ((!#[ \t]*/.*[jp]ython[0-9.]* . python-mode) (%PDF . pdf-view-mode))

* projectile
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :hook (gradle-mode . projectile-mode))

  (use-package helm-projectile
    :ensure t
    :config
    (helm-projectile-on))
#+END_SRC

#+RESULTS:
: t

* python
#+BEGIN_SRC emacs-lisp
  ;; (use-package anaconda-mode
  ;;   :ensure t
  ;;   :hook
  ;;   (python-mode . anaconda-mode)
  ;;   (python-mode . anaconda-eldoc-mode))

  ;; ;;spacing around operators
  ;; (use-package electric-operator
  ;;   :ensure t
  ;;   :hook ((ess-mode python-mode) . electric-operator-mode))

  ;; (use-package python-mode
  ;;   :ensure t)


  ;; ;;for autocompletion
  ;; (use-package company-jedi
  ;;   :ensure t)


  (use-package elpy
    :ensure t)
#+END_SRC

#+RESULTS:

* Texfrag
#+BEGIN_SRC emacs-lisp :results silent
  (use-package texfrag
	:ensure t
	:config
	;;(texfrag-global-mode t)
	:hook
	(org-mode . texfrag-mode)
	:diminish "Frag"
	)
#+END_SRC

* try
#+BEGIN_SRC emacs-lisp
  (use-package try
    :ensure t)
#+END_SRC

#+RESULTS:

* Undo Tree
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
	:ensure t
	:init (global-undo-tree-mode)
	:diminish
	)
#+END_SRC

#+RESULTS:
|   |

* virtualenvwrapper
#+BEGIN_SRC emacs-lisp
  (use-package virtualenvwrapper
    :ensure t
    :config
    (progn
      ;;(venv-initialize-eshell)
      (setq venv-location "~/.virtualenvs")))
#+END_SRC

* web-mode
#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :mode (("\\.html\\'" . web-mode)
           ("\\.html\\.erb\\'" . web-mode)
           ("\\.mustache\\'" . web-mode)
           ("\\.jinja\\'" . web-mode)
           ("\\.php\\'" . web-mode))
    :config
    (progn
      (setq web-mode-engines-alist
            '(("\\.jinja\\'"  . "django")))))
#+END_SRC

#+RESULTS:

* yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t)

  (use-package java-snippets
    :ensure t)
#+END_SRC

* move file
#+BEGIN_SRC emacs-lisp
  (defun move-file (new-location)
    "Write this file to NEW-LOCATION, and delete the old one."
    (interactive (list (expand-file-name
                        (if buffer-file-name
                            (read-file-name "Move file to: ")
                          (read-file-name "Move file to: "
                                          default-directory
                                          (expand-file-name (file-name-nondirectory (buffer-name))
                                                            default-directory))))))
    (when (file-exists-p new-location)
      (delete-file new-location))
    (let ((old-location (expand-file-name (buffer-file-name))))
      (message "old file is %s and new file is %s"
               old-location
               new-location)
      (write-file new-location t)
      (when (and old-location
                 (file-exists-p new-location)
                 (not (string-equal old-location new-location)))
        (delete-file old-location))))
  (bind-key "C-x C-m" #'move-file)
#+END_SRC

#+RESULTS:
: move-file

* toggle split
#+BEGIN_SRC emacs-lisp
  (defun toggle-window-split ()
    (interactive)
    (if (= (count-windows) 2)
        (let* ((this-win-buffer (window-buffer))
               (next-win-buffer (window-buffer (next-window)))
               (this-win-edges (window-edges (selected-window)))
               (next-win-edges (window-edges (next-window)))
               (this-win-2nd (not (and (<= (car this-win-edges)
                                           (car next-win-edges))
                                       (<= (cadr this-win-edges)
                                           (cadr next-win-edges)))))
               (splitter
                (if (= (car this-win-edges)
                       (car (window-edges (next-window))))
                    'split-window-horizontally
                  'split-window-vertically)))
          (delete-other-windows)
          (let ((first-win (selected-window)))
            (funcall splitter)
            (if this-win-2nd (other-window 1))
            (set-window-buffer (selected-window) this-win-buffer)
            (set-window-buffer (next-window) next-win-buffer)
            (select-window first-win)
            (if this-win-2nd (other-window 1))))))

  (global-set-key (kbd "C-x |") 'toggle-window-split)
#+END_SRC

#+RESULTS:
: toggle-window-split

* change directory
#+BEGIN_SRC emacs-lisp
;;(cd (getenv "OneDriveBash"))
#+END_SRC


* spellcheck
#+BEGIN_SRC emacs-lisp
  ;; find aspell and hunspell automatically
  (cond

   ((executable-find "aspell")
	(setq ispell-program-name "aspell")
	;; Please note ispell-extra-args contains ACTUAL parameters passed to aspell
	(setq ispell-extra-args '("--mode=tex" "-t" "--sug-mode=ultra" "--lang=en_US"))))

  (eval-after-load "flyspell"
	'(progn
	   (define-key flyspell-mouse-map [mouse-3] #'flyspell-correct-word)))


  (defun endless/org-ispell ()
	(make-local-variable 'ispell-skip-region-alist)

	(defconst help/org-special-pre "^\s*#[+]")
	(defun help/block-regex (special)
	  "Make an ispell skip-region alist for a SPECIAL block."
	  (interactive)
	  `(,(concat help/org-special-pre "BEGIN_" special)
		.
		,(concat help/org-special-pre "END_" special)))

	(add-to-list 'ispell-skip-region-alist (help/block-regex "SRC"))
	(add-to-list 'ispell-skip-region-alist (help/block-regex "EXAMPLE"))
	(add-to-list 'ispell-skip-region-alist '("^\s*:PROPERTIES\:$" . "^\s*:END\:$"))
	(let ()
	  (--each
		  '(("ATTR_LATEX" nil)
			("AUTHOR" nil)
			("BLOG" nil)
			("CREATOR" nil)
			("DATE" nil)
			("DESCRIPTION" nil)
			("EMAIL" nil)
			("EXPORT" nil)
			("EXCLUDE_TAGS" nil)
			("HTML_CONTAINER" nil)
			("HTML_DOCTYPE" nil)
			("HTML_HEAD" nil)
			("HTML_HEAD_EXTRA" nil)
			("HTML_LINK_HOME" nil)
			("HTML_LINK_UP" nil)
			("HTML_MATHJAX" nil)
			("INFOJS_OPT" nil)
			("KEYWORDS" nil)
			("LANGUAGE" nil)
			("LATEX_CLASS" nil)
			("LATEX_CLASS_OPTIONS" nil)
			("LATEX_HEADER" nil)
			("LATEX_HEADER_EXTRA" nil)
			("NAME" t)
			("OPTIONS" t)
			("POSTID" nil)
			("RESULTS" t)
			("SELECT_TAGS" nil)
			("STARTUP" nil)
			("TITLE" nil))
		(add-to-list
		 'ispell-skip-region-alist
		 (let ((special (concat "#[+]" (car it) ":")))
		   (if (cadr it)
			   (cons special "$")
			 (list special)))))))
  (add-hook 'org-mode-hook #'endless/org-ispell)


#+END_SRC

#+RESULTS:
: t

** helm flyspell
#+BEGIN_SRC emacs-lisp
;;courtesy of  https://emacs.stackexchange.com/a/14917  
(defun flyspell-goto-previous-error (arg)
	"Go to arg previous spelling error."
	(interactive "p")
	(while (not (= 0 arg))
	  (let ((pos (point))
			(min (point-min)))
		(if (and (eq (current-buffer) flyspell-old-buffer-error)
				 (eq pos flyspell-old-pos-error))
			(progn
			  (if (= flyspell-old-pos-error min)
				  ;; goto beginning of buffer
				  (progn
					(message "Restarting from end of buffer")
					(goto-char (point-max)))
				(backward-word 1))
			  (setq pos (point))))
		;; seek the next error
		(while (and (> pos min)
					(let ((ovs (overlays-at pos))
						  (r '()))
					  (while (and (not r) (consp ovs))
						(if (flyspell-overlay-p (car ovs))
							(setq r t)
						  (setq ovs (cdr ovs))))
					  (not r)))
		  (backward-word 1)
		  (setq pos (point)))
		;; save the current location for next invocation
		(setq arg (1- arg))
		(setq flyspell-old-pos-error pos)
		(setq flyspell-old-buffer-error (current-buffer))
		(goto-char pos)
		(if (= pos min)
			(progn
			  (message "No more miss-spelled word!")
			  (setq arg 0))))))


  (defun check-previous-spelling-error ()
	"Jump to previous spelling error and correct it"
	(interactive)
	(push-mark-no-activate)
	(flyspell-goto-previous-error 1)
	(call-interactively 'helm-flyspell-correct)
	(pop-global-mark))

  (defun check-next-spelling-error ()
	"Jump to next spelling error and correct it"
	(interactive)
	(push-mark-no-activate)
	(flyspell-goto-next-error)
	(call-interactively 'helm-flyspell-correct))

  (defun push-mark-no-activate ()
	"Pushes `point' to `mark-ring' and does not activate the region
   Equivalent to \\[set-mark-command] when \\[transient-mark-mode] is disabled"
	(interactive)
	(push-mark (point) t nil)
	(message "Pushed mark to ring"))

  (use-package helm-flyspell
	:ensure t
	:config
	(define-key flyspell-mode-map (kbd "C-;") 'check-previous-spelling-error))

#+END_SRC

* powerline
see [[file:nhh-lisp/mode-line.el][Mode Line Setup]]


#+RESULTS:
: t

* multiple cursors
#+BEGIN_SRC emacs-lisp
  ;;get rid of nasty secondary selection keybindings
  (delete-overlay mouse-secondary-overlay)
  (global-unset-key [M-mouse-1])
  (global-unset-key [M-drag-mouse-1])
  (global-unset-key [M-down-mouse-1])
  (global-unset-key [M-mouse-3])
  (global-unset-key [M-mouse-2])

  (use-package multiple-cursors
    :ensure t
    )

  ;;sets return to enter new line rather than exit multiple cursors
  (define-key mc/keymap (kbd "<return>") nil)


  (global-set-key (kbd "C->") 'mc/mark-next-like-this)
  (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)

  (global-set-key
   (kbd "C-c m c")
   (defhydra multiple-cursors-hydra (:hint nil)
     "
           ^Up^            ^Down^        ^Other^
      ----------------------------------------------
      [_p_]   Next    [_n_]   Next    [_l_] Edit lines
      [_P_]   Skip    [_N_]   Skip    [_a_] Mark all
      [_M-p_] Unmark  [_M-n_] Unmark  [_r_] Mark by regexp
      ^ ^             ^ ^             [_q_] Quit
      "
     ("l" mc/edit-lines :exit t)
     ("a" mc/mark-all-like-this :exit t)
     ("n" mc/mark-next-like-this)
     ("N" mc/skip-to-next-like-this)
     ("M-n" mc/unmark-next-like-this)
     ("p" mc/mark-previous-like-this)
     ("P" mc/skip-to-previous-like-this)
     ("M-p" mc/unmark-previous-like-this)
     ("r" mc/mark-all-in-region-regexp :exit t)
     ("q" nil)
     ("<mouse-1>" mc/add-cursor-on-click)
     ("<down-mouse-1>" ignore)
     ("<drag-mouse-1>" ignore)))

#+END_SRC

#+RESULTS:
=multiple-cursors-hydra/body
=* plantuml
#+BEGIN_SRC emacs-lisp
  (use-package plantuml-mode
	:ensure t
	:config
	(add-to-list 'auto-mode-alist '("\\.plantuml\\'" . plantuml-mode))
	)
#+END_SRC

#+RESULTS:
: t

* dictionary
#+BEGIN_SRC emacs-lisp
  (use-package adaptive-wrap
	:ensure t)
  (use-package wordnut
	:ensure t
	:bind (("C-c d" . wordnut-lookup-current-word)
		   ("C-c D" . wordnut-search))
	)
#+END_SRC

#+RESULTS:
: wordnut-search
* yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
	:ensure t
	:config
	(setq yas-snippet-dirs '("~/.emacs.d/snippets"))
	(yas-global-mode)
	(diminish 'yas-minor-mode)
	)
#+END_SRC

#+RESULTS:

* custom lisp
#+BEGIN_SRC emacs-lisp
  (defun load-directory (dir)
    (let ((load-it (lambda (f)
                     (load-file (concat (file-name-as-directory dir) f)))
                   ))
      (mapc load-it (directory-files dir nil "\\.el$"))))
  (load-directory "~/.emacs.d/nhh-lisp")

  (if (string-equal system-name "nick-laptop")
      (setq powerline-height 30)
    (string-equal system-name "nick-pc")
    (setq powerline-height 20)
    (set-face-attribute 'default nil :height 130)
    )


  (load-theme 'zenburn)
  (powerline-reset)
#+END_SRC

#+RESULTS:
| mode-line.el | set-theme.el |
* recent files
#+BEGIN_SRC emacs-lisp
  (recentf-mode 1)
  (setq recentf-max-menu-items 25)
  (global-set-key "\C-x\ \C-r" 'helm-recentf)
#+END_SRC

#+RESULTS:
: helm-recentf



test
* terminal

#+BEGIN_SRC emacs-lisp
  (add-hook 'eshell-mode-hook (lambda ()
                                (setq-local global-hl-line-mode
                                            nil)))
  (add-hook 'term-mode-hook (lambda ()
                              (setq-local global-hl-line-mode
                                          nil)))
#+END_SRC

#+RESULTS:
| lambda | nil | (setq-local global-hl-line-mode nil) |

* bash completion
#+BEGIN_SRC emacs-lisp
  (use-package bash-completion
    :ensure t
    :config
    (bash-completion-setup)
    )
#+END_SRC

#+RESULTS:
: t

* haskell
#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :ensure t
    :config
    ;; add capability to submit code to interpreter and mark errors
    ;;    (add-hook 'haskell-mode-hook 'interactive-haskell-mode)
    (add-hook 'haskell-mode-hook '(lambda () (aggressive-indent-mode 0)))

    ;; add missing keybindings for navigating errors
    ;; (define-key interactive-haskell-mode-map (kbd "M-n") 'haskell-goto-next-error)
    ;; (define-key interactive-haskell-mode-map (kbd "M-p") 'haskell-goto-prev-error)
    ;; (define-key interactive-haskell-mode-map (kbd "C-c M-p") 'haskell-goto-first-error)

    ;; merge this with your existing custom-set-variables
    (custom-set-variables

     ;; NOTE: include following line to work around haskell-mode
     ;; bug if using GHC >= 8.2.1.
     ;; See: https://github.com/haskell/haskell-mode/issues/1553
     '(haskell-process-args-stack-ghci
       '("--ghci-options=-ferror-spans -fshow-loaded-modules"
         "--no-build" "--no-load"))

     ;; some options suggested in the haskell-mode documentation
     '(haskell-process-auto-import-loaded-modules t)
     '(haskell-process-log t)
     '(haskell-process-suggest-remove-import-lines t)

     ;; make sure "stack ghci" is used, even in the global project
     '(haskell-process-type 'stack-ghci)))



    (use-package intero
      :ensure t
      :config
      (add-hook 'haskell-mode-hook 'intero-mode))




#+END_SRC

#+RESULTS:
: t

* which key
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :config
    (which-key-mode))
#+END_SRC

#+RESULTS:
: t

